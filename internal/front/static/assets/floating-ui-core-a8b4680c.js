function T(t){return t.split("-")[1]}function C(t){return t==="y"?"height":"width"}function D(t){return t.split("-")[0]}function O(t){return["top","bottom"].includes(D(t))?"x":"y"}function j(t,e,x){let{reference:n,floating:r}=t;const s=n.x+n.width/2-r.width/2,l=n.y+n.height/2-r.height/2,c=O(e),m=C(c),u=n[m]/2-r[m]/2,f=c==="x";let i;switch(D(e)){case"top":i={x:s,y:n.y-r.height};break;case"bottom":i={x:s,y:n.y+n.height};break;case"right":i={x:n.x+n.width,y:l};break;case"left":i={x:n.x-r.width,y:l};break;default:i={x:n.x,y:n.y}}switch(T(e)){case"start":i[c]-=u*(x&&f?-1:1);break;case"end":i[c]+=u*(x&&f?-1:1)}return i}const I=async(t,e,x)=>{const{placement:n="bottom",strategy:r="absolute",middleware:s=[],platform:l}=x,c=s.filter(Boolean),m=await(l.isRTL==null?void 0:l.isRTL(e));let u=await l.getElementRects({reference:t,floating:e,strategy:r}),{x:f,y:i}=j(u,n,m),a=n,o={},d=0;for(let y=0;y<c.length;y++){const{name:p,fn:A}=c[y],{x:h,y:w,data:k,reset:g}=await A({x:f,y:i,initialPlacement:n,placement:a,strategy:r,middlewareData:o,rects:u,platform:l,elements:{reference:t,floating:e}});f=h??f,i=w??i,o={...o,[p]:{...o[p],...k}},g&&d<=50&&(d++,typeof g=="object"&&(g.placement&&(a=g.placement),g.rects&&(u=g.rects===!0?await l.getElementRects({reference:t,floating:e,strategy:r}):g.rects),{x:f,y:i}=j(u,a,m)),y=-1)}return{x:f,y:i,placement:a,strategy:r,middlewareData:o}};function F(t,e){return typeof t=="function"?t(e):t}function V(t){return typeof t!="number"?function(e){return{top:0,right:0,bottom:0,left:0,...e}}(t):{top:t,right:t,bottom:t,left:t}}function J(t){return{...t,top:t.y,left:t.x,right:t.x+t.width,bottom:t.y+t.height}}const E=Math.min,q=Math.max;function z(t,e,x){return q(t,E(e,x))}const K=t=>({name:"arrow",options:t,async fn(e){const{x,y:n,placement:r,rects:s,platform:l,elements:c}=e,{element:m,padding:u=0}=F(t,e)||{};if(m==null)return{};const f=V(u),i={x,y:n},a=O(r),o=C(a),d=await l.getDimensions(m),y=a==="y",p=y?"top":"left",A=y?"bottom":"right",h=y?"clientHeight":"clientWidth",w=s.reference[o]+s.reference[a]-i[a]-s.floating[o],k=i[a]-s.reference[a],g=await(l.getOffsetParent==null?void 0:l.getOffsetParent(m));let v=g?g[h]:0;v&&await(l.isElement==null?void 0:l.isElement(g))||(v=c.floating[h]||s.floating[o]);const S=w/2-k/2,P=v/2-d[o]/2-1,M=E(f[p],P),B=E(f[A],P),R=M,H=v-d[o]-B,b=v/2-d[o]/2+S,L=z(R,b,H),W=T(r)!=null&&b!=L&&s.reference[o]/2-(b<R?M:B)-d[o]/2<0?b<R?R-b:H-b:0;return{[a]:i[a]-W,data:{[a]:L,centerOffset:b-L+W}}}}),G=["top","right","bottom","left"];G.reduce((t,e)=>t.concat(e,e+"-start",e+"-end"),[]);const N=function(t){return t===void 0&&(t=0),{name:"offset",options:t,async fn(e){const{x,y:n}=e,r=await async function(s,l){const{placement:c,platform:m,elements:u}=s,f=await(m.isRTL==null?void 0:m.isRTL(u.floating)),i=D(c),a=T(c),o=O(c)==="x",d=["left","top"].includes(i)?-1:1,y=f&&o?-1:1,p=F(l,s);let{mainAxis:A,crossAxis:h,alignmentAxis:w}=typeof p=="number"?{mainAxis:p,crossAxis:0,alignmentAxis:null}:{mainAxis:0,crossAxis:0,alignmentAxis:null,...p};return a&&typeof w=="number"&&(h=a==="end"?-1*w:w),o?{x:h*y,y:A*d}:{x:A*d,y:h*y}}(e,t);return{x:x+r.x,y:n+r.y,data:r}}}};export{N as L,K as g,I as r,J as s};
